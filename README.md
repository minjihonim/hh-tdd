# 동시성 제어 방식에 대한 분석 및 보고서
## 동시성 제어
### 정의
- 동시성 제어는 여러 쓰레드나 프로세스가 같은 자원에 동시에 접근할 때 발생할 수 있는 충돌이나 문제를 방지하는 방법
### 필요성
- 데이터의 일관성과 무결성을 유지하기 위함
  - 충돌 방지: 한 쓰레드가 작업을 완료할 때까지 다른 쓰레드가 자원에 접근하지 못하게 함
  - 일관성 보장: 작업이 정확히 한 번씩만 처리되도록 보장
  - 신뢰성 유지: 결과가 정확하도록 보장

### 동시성 제어를 하지 않으면 발생할 수 있는 문제  

---------------

### Race Condition
- 둘 이상의 스레드가 동시에 공유 자원에 접근할 때, 실행 순서에 따라 결과가 달라지는 문제
- 예시)
```
- 멀티 쓰레드 환경
- 유저 A: 보유 포인트 100
- 유저 A: 포인트 충전 요청을 50씩 2번 보냄
- 두개의 충전 스레드가 순차적으로 수행 못하고 동시에 수행 됨
- 유저는 200 포인트를 보유한 상태여야 하지만, 150 포인트만 보유하게 되는 현상 발생
```

### 과제에서 고려해야 할 동시성 제어 요건
- 단일 서버 환경
- 각 유저의 요청은 순차적으로 처리: 각 유저가 보내는 요청은 순차적으로 처리되어야 함
- 유저 간 독립성 보장: 유저 간의 요청은 독립적으로 처리되어야 하며, 한 유저의 요청이 다른 유저의 요청을 기다리지 않아야 함

## 단일 서버 환경에서 쓰레드 기반 동시성 제어 설계
### 쓰레드 기반 자바 동시성 제어 주요 방법
1. synchronized
- 특징: 한 번에 하나의 쓰레드만 특정 코드에 접근할 수 있도록 자동으로 락을 걸어줌.
- 장점: 코드가 간단하고 요청 순서를 보장하여 안정적인 처리 가능.
- 단점: 성능 저하, 락이 직렬화되어 다른 요청들이 대기하게 되며, 교착 상태가 발생할 수 있음.
2. ReentrantLock
- 특징: 명시적으로 lock()과 unlock()을 사용해 락을 제어, 공정성(Fairness) 설정을 통해 요청 순서를 보장할 수 있음.
- 장점: 유저별로 독립적인 락을 생성하고 세밀한 락 제어가 가능. tryLock()을 사용해 데드락을 방지할 수 있음.
- 단점: 락 해제를 명시적으로 해야 하므로 관리가 복잡하고, 유저 수가 많으면 메모리 사용량이 증가할 수 있음.
3. ConcurrentHashMap
- 특징: 내부적으로 데이터를 버킷 단위로 나누어 락을 걸어 다중 쓰레드 환경에서 안전한 데이터 읽기/쓰기를 가능하게 함.
- 장점: 높은 동시성을 제공하며, 유저별 데이터 관리가 용이.
- 단점: 요청 순서를 보장하지 않으므로, 순차적인 처리가 필요한 경우엔 적합하지 않음.
4. ConcurrentLinkedQueue
- 특징: 비블로킹 큐로, FIFO(First In First Out) 순서대로 작업을 처리. 락 없이 CAS(Compare-And-Swap) 방식을 사용.
- 장점: 여러 쓰레드가 동시에 큐에 안전하게 접근하여 고성능 동시성 처리가 가능.
- 단점: 순차적인 연산보다는 병렬 처리에 적합하며, 특정 위치의 데이터에 접근하거나 검색하는 데는 비효율적.

## 동시성 제어방식 선택
### ReentrantLock + ConcurrentHashMap
```순차성 보장은 락으로, 락 관리는 해시맵으로```

ReentrantLock으로 생성된 여러 락들의 작업 간 충돌을 방지하려면 락 객체를 저장하고 관리할 공간이 필요한데, ConcurrentHashMap으로 이를 효과적으로 관리 할 수 있음
ConcurrentHashMap은 락을 키별로 저장하고 관리할 수 있고,
내부적으로 데이터를 세그먼트 단위로 나눠 처리하므로, 특정 키 작업이 다른 작업에 영향을 덜 미치도록 함

따라서 ReentrantLock은 유저별 요청 순차성 보장을 위해, ConcurrentHashMap은 유저별 락 객체 관리 및 독립적인 요청 처리를 위해 함께 사용

- 유저 별 요청 순차성 보장을 위해 ReentrantLock로 유저별 락 생성
- 여러 유저의 요청을 독립적으로 처리하기 위해 ConcurrentHashMap을 사용하여 ReentrantLock 객체 관리
### 구현
락 객체 관리
- 유저의 ID를 키로, ReentrantLock을 값으로 관리하는 ConcurrentHashMap<Long, ReentrantLock>을 사용.
### 유저별 락을 통한 순차 처리
- 각 유저의 요청은 락을 얻은 후 순차적으로 처리되며, 작업이 끝나면 락을 해제 (lock.unlock()).
- 요청이 완료될 때까지 다른 요청은 대기하도록 순차적으로 처리.
### 락의 독립성 보장
- 각 유저는 독립적으로 락을 관리하므로, 유저 A의 요청이 유저 B의 요청을 기다리지 않음.
- 유저별 락을 사용하여 유저 간 요청이 독립적으로 처리되며 동시성 문제가 발생하지 않음.
### 예외 처리
- 예외가 발생한 경우에도 finally 블록에서 락을 반드시 해제하여, 시스템이 정상적으로 동작하도록 보장.